/////////////////////////////////////////////////////////////////////////////
// EffFrq.cpp : Implementation of the CAudEff frequency classes
// Copyright (c) 1987-1996 Andrew J. Michalik
/////////////////////////////////////////////////////////////////////////////
#include "gencif.h"						// Generic C I/F application defs

#include "audfil.h"						// Audio file support defs
#include "audeff.h"						// Audio effects support defs

extern "C"
{
	#include <math.h>					// Math library defs
}

/////////////////////////////////////////////////////////////////////////////
//	Note: MSC 8.0 bug when compiling with Compiler Optimizations = Max Speed
//	Equalizer generates zeros for output data. Is this related
//	to ToolBox 2.00d EffFtr.c MSC 8.0 -Ocglt bug?
/////////////////////////////////////////////////////////////////////////////
#pragma optimize("", off)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
WORD CALLBACK EXPORT	CFrqEff::FrqEffCBk (float FAR * FAR *ppflSrcBuf, 
				DWORD FAR *lpulDstCnt, DWORD ulBufPts, DWORD ulTotPts, 
				DWORD ulHdrPts, DWORD ulCtrPts, DWORD ulDstRem, LPFFTB lpFFTBlk)
{
	CEffEqu FAR	*lpEffEqu = (CEffEqu FAR *) lpFFTBlk->lpUsrDat;
	CPXFLT	FAR	*lpFFTCpx = (CPXFLT FAR *)(*ppflSrcBuf);
	CPXFLT	FAR	*lpXfrBuf;
	float		*lpWinBuf;
	DWORD		uli;
			   	
	/////////////////////////////////////////////////////////////////////////
	// The EffFFTFtr (calling routine) delivers a set of data points where
	// ulCtrPts at offset ulHdrPts have been correctly isolated to implement
	// the overlap-save method of FFT corruption prevention.
	/////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////
	// Default returned data count to zero
	/////////////////////////////////////////////////////////////////////////
	*lpulDstCnt = 0L;

	/////////////////////////////////////////////////////////////////////////
	// Completion pass? Indicate done processing...
	/////////////////////////////////////////////////////////////////////////
	if (!ulCtrPts) return (FALSE);

	/////////////////////////////////////////////////////////////////////////
	// Space available in output? Enough room for resampling?
	/////////////////////////////////////////////////////////////////////////
	if (ulDstRem < ulCtrPts * lpFFTBlk->flResRat) return (FALSE);
	if (ulBufPts < ulTotPts * lpFFTBlk->flResRat) return (FALSE);

	/////////////////////////////////////////////////////////////////////////
	// Window incoming data
	/////////////////////////////////////////////////////////////////////////
	if (NULL != (lpWinBuf = (float FAR *) GloMemLck (lpFFTBlk->mhWinHdl))) {
		for (uli=0; uli < ulTotPts; uli++) (*ppflSrcBuf)[uli] *= lpWinBuf[uli];
		GloMemUnL (lpFFTBlk->mhWinHdl);
	}

	/////////////////////////////////////////////////////////////////////////
	// Transform to frequency domain
	/////////////////////////////////////////////////////////////////////////
	EffFFTRea (*ppflSrcBuf, (WORD) (ulTotPts / 2L), EFFFFTFWD);

	/////////////////////////////////////////////////////////////////////////
	// Lock FFT filter transfer buffer
	/////////////////////////////////////////////////////////////////////////
	if (NULL == (lpXfrBuf = (CPXFLT FAR *) GloMemLck (lpFFTBlk->mhXfrHdl))) 
		return (FALSE);

	/////////////////////////////////////////////////////////////////////////
	// Handle DC and Nyquist as special case; pack into real data FFT format
	/////////////////////////////////////////////////////////////////////////
	lpFFTCpx[0].flRea *= lpXfrBuf[0].flRea;
	lpFFTCpx[0].flImg *= lpXfrBuf[0].flImg;

	/////////////////////////////////////////////////////////////////////////
	// Apply filter function, unlock filter transfer buffer when done
	/////////////////////////////////////////////////////////////////////////
	for (uli = 1L; uli < ulTotPts / 2L; uli++) {
		CpxMul (lpFFTCpx[uli], lpXfrBuf[uli], &lpFFTCpx[uli]);
	}
	GloMemUnL (lpFFTBlk->mhXfrHdl);

	/////////////////////////////////////////////////////////////////////////
	// Pad with zero if required; transform back to time domain
	// Note: MSC 8.0 bug when compiling DLL with -Ocglt: 
	/////////////////////////////////////////////////////////////////////////
	for (uli=ulTotPts; uli < ulBufPts; uli++) (*ppflSrcBuf)[uli] = (float) 0;
	EffFFTRea (*ppflSrcBuf, (WORD) ((ulTotPts * lpFFTBlk->flResRat) / 2), EFFFFTINV);

	/////////////////////////////////////////////////////////////////////////
	// Set Output buffer to point to good samples (past header)
	/////////////////////////////////////////////////////////////////////////
	*ppflSrcBuf = &(*ppflSrcBuf)[(DWORD) (ulHdrPts * lpFFTBlk->flResRat)];

	/////////////////////////////////////////////////////////////////////////
	// Indicate number of valid output samples and continue processing
	/////////////////////////////////////////////////////////////////////////
	*lpulDstCnt = (DWORD) (ulCtrPts * lpFFTBlk->flResRat);

//	/////////////////////////////////////////////////////////////////////////
//	// Correct energy level for re-sample
//	/////////////////////////////////////////////////////////////////////////
//	if (1 != lpFFTBlk->flResRat) for (uli=0; uli < ulCtrPts * lpFFTBlk->flResRat; uli++) 
//		(*ppflSrcBuf)[uli] *= lpFFTBlk->flResRat;

	/////////////////////////////////////////////////////////////////////////
	// Return TRUE to continue processing
	/////////////////////////////////////////////////////////////////////////
	return (TRUE);

}

/////////////////////////////////////////////////////////////////////////////
//	End MSC 8.0 bug
/////////////////////////////////////////////////////////////////////////////
#pragma optimize("", on)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffAAF::CEffAAF (DWORD ulLowPas, DWORD ulSmpFrq, AAFALG usAAFAlg)
{
	/////////////////////////////////////////////////////////////////////////
	// Initialize Time Domain & FFT blocks to insure safe destructor release
	/////////////////////////////////////////////////////////////////////////
	memset (&m_tfTDoFtr, 0, sizeof (m_tfTDoFtr));
	memset (&m_fbFFTBlk, 0, sizeof (m_fbFFTBlk));

	/////////////////////////////////////////////////////////////////////////
	// Default: Turn anti-aliasing off
	/////////////////////////////////////////////////////////////////////////
	m_usAAFAlg = AAFALGNON;			

	/////////////////////////////////////////////////////////////////////////
	// Is cut-off frequency at or beyond Nyquist?
	/////////////////////////////////////////////////////////////////////////
	if (ulLowPas >= ulSmpFrq / 2L) return;

	/////////////////////////////////////////////////////////////////////////
	// Initialize / allocate IIR filter function block
	/////////////////////////////////////////////////////////////////////////
	if (FtrIIR (ulLowPas, ulSmpFrq, usAAFAlg)) return;
	if (FtrFFT (ulLowPas, ulSmpFrq, usAAFAlg)) return;

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	return;

}

BOOL	CEffAAF::FtrIIR (DWORD ulLowPas, DWORD ulSmpFrq, AAFALG usAAFAlg) 
{
	WORD	usSecCnt;
	WORD	usSecOrd;
	BOOL	bfFstFlg;

	/////////////////////////////////////////////////////////////////////////
	// IIR-type algorithm?
	/////////////////////////////////////////////////////////////////////////
	switch (usAAFAlg) {
		case AAFALGFST:
		case AAFALGNRM:
			usSecCnt = Q2_SECCNT;			
			usSecOrd = Q2_SECORD;
			bfFstFlg = (AAFALGFST == usAAFAlg);
			break;
		case AAFALG6II:
		case AAFALG6IF:
			usSecCnt = Q6_SECCNT;			
			usSecOrd = Q6_SECORD;
			bfFstFlg = (AAFALG6IF == usAAFAlg);
			break;
		default:
			return (FALSE);
	}

	/////////////////////////////////////////////////////////////////////////
	// Initialize / allocate 2 pole filter function block
	/////////////////////////////////////////////////////////////////////////
	if (EffIIRAlo (EFFIIRCH2, EFFPASLOW, usSecCnt, usSecOrd, ulLowPas, 0L, 
	  AAFPASFAC, AAFSTPATT, ulSmpFrq, bfFstFlg, &m_tfTDoFtr)) {
		CIFDspRes (MB_OKCANCEL, IDS_AAFALGERR);
	}
	else m_usAAFAlg = usAAFAlg;

	/////////////////////////////////////////////////////////////////////////
	// Indicate that request was for IIR-type filter (even if failed init)
	/////////////////////////////////////////////////////////////////////////
	return (TRUE);

}

BOOL	CEffAAF::FtrFFT (DWORD ulLowPas, DWORD ulSmpFrq, AAFALG usAAFAlg)
{
	float  *lpWinBuf;
	LPCPXF  lpXfrBuf;
	DWORD   ulCutOff;
	DWORD   uli;

	/////////////////////////////////////////////////////////////////////////
	// Initialize FFT block
	/////////////////////////////////////////////////////////////////////////
	if (EffFFTAlo (FFTORDDEF, 1, &m_fbFFTBlk, (EFFPOLPRC) NULL, 0L)) {
		CIFDspRes (MB_OKCANCEL, IDS_AAFALGERR);
		return (TRUE);									// FFTALG, but failed
	}	

	/////////////////////////////////////////////////////////////////////////
	// Lock data window memory, initialize
	// Note: Data window is twice the FFT point size - overlap saved
	/////////////////////////////////////////////////////////////////////////
	if (NULL != (lpWinBuf = (float FAR *) GloMemLck (m_fbFFTBlk.mhWinHdl))) {
		EffWinGen (EFFWINTAP, lpWinBuf, 2 * m_fbFFTBlk.ulFFTPts);
		GloMemUnL (m_fbFFTBlk.mhWinHdl);
	}

	/////////////////////////////////////////////////////////////////////////
	// Back frequency off by 90%										*/	
	/////////////////////////////////////////////////////////////////////////
	ulLowPas = (DWORD) (ulLowPas * .9);

	/////////////////////////////////////////////////////////////////////////
	// Lock FFT filter transfer buffer
	/////////////////////////////////////////////////////////////////////////
	if (NULL == (lpXfrBuf = (LPCPXF) GloMemLck (m_fbFFTBlk.mhXfrHdl))) {
		CIFDspRes (MB_OKCANCEL, IDS_AAFALGERR);
		return (TRUE);									// FFTALG, but failed
	}

	/////////////////////////////////////////////////////////////////////////
	// Handle DC and N/2 as special case; pack into real FFT format
	// Calculate complex cutoff frequency bin
	// Zero complex transfer function above cut-off frequency
	/////////////////////////////////////////////////////////////////////////
	lpXfrBuf[0].flRea = lpXfrBuf[0].flImg = 0;
	ulCutOff = (m_fbFFTBlk.ulFFTPts * ulLowPas) / (ulSmpFrq / 2L);
	for (uli=ulCutOff; uli < m_fbFFTBlk.ulFFTPts; uli++) {
		lpXfrBuf[uli].flRea = 0;	   
		lpXfrBuf[uli].flImg = 0;
	}

	/////////////////////////////////////////////////////////////////////////
	// Convert infinite length transfer functions into valid frequency
	// domain filter. Unlock transfer buffer memory.
	/////////////////////////////////////////////////////////////////////////
	EffWinRsp (EFFWINHAM, lpXfrBuf, m_fbFFTBlk.ulFFTPts); 
	GloMemUnL (m_fbFFTBlk.mhXfrHdl);

	/////////////////////////////////////////////////////////////////////////
	// Indicate algorithm type & exit
	/////////////////////////////////////////////////////////////////////////
	m_usAAFAlg = usAAFAlg;
	return (TRUE);

}

CAudEff	*	CEffAAF::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	// Filter according to algorithm type
	/////////////////////////////////////////////////////////////////////////
	switch (m_usAAFAlg) {
		case AAFALGFST:
		case AAFALGNRM:
		case AAFALG6II:
		case AAFALG6IF:
			EffIIRFtr (pAudEff->GetEBSBlk(), &m_ebEBSBlk, &m_tfTDoFtr);
			break;
		case AAFALGFFT:
			EffFFTFtr (pAudEff->GetEBSBlk(), &m_ebEBSBlk, &m_fbFFTBlk, 
				(EFFFFTCBK) FrqEffCBk, this);
			break;
		default:
			EffEBStoE (pAudEff->GetEBSBlk(), &m_ebEBSBlk, (DWORD) -1L);
	}
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

CEffAAF::~CEffAAF ()
{
	/////////////////////////////////////////////////////////////////////////
	// Release Time Domain & FFT blocks; constructor inits for safe release
	/////////////////////////////////////////////////////////////////////////
	EffFFTRel (&m_fbFFTBlk);
	EffIIRRel (&m_tfTDoFtr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffDTM::CEffDTM (DWORD ulSmpFrq, DTMALG usDTMAlg)
{
	#define HAMWIN(s,p) (0.54-0.46*cos((double)(p*2)*dbPI/((double)s-1.0)))
	NCHFTR  nfDTMF = {8, 697, 770, 852, 941, 1209, 1336, 1477, 1633};
	float  *lpWinBuf;
	LPCPXF  lpXfrBuf;
	WORD	usi;

	/////////////////////////////////////////////////////////////////////////
	// Default: Turn DTMF filtering off
	/////////////////////////////////////////////////////////////////////////
	m_usDTMAlg = DTMALGNON;			

	/////////////////////////////////////////////////////////////////////////
	// Initialize FFT block; allocate inits for safe destructor release
	/////////////////////////////////////////////////////////////////////////
	if (EffFFTAlo (FFTORDDEF, 1, &m_fbFFTBlk, (EFFPOLPRC) NULL, 0L)) {
		CIFDspRes (MB_OKCANCEL, IDS_DTMALGERR);
		return;
	}	

	/////////////////////////////////////////////////////////////////////////
	// Lock data window memory, initialize
	// Note: Data window is twice the FFT point size - overlap saved
	/////////////////////////////////////////////////////////////////////////
	if (NULL != (lpWinBuf = (float FAR *) GloMemLck (m_fbFFTBlk.mhWinHdl))) {
		EffWinGen (EFFWINTAP, lpWinBuf, 2 * m_fbFFTBlk.ulFFTPts);
		GloMemUnL (m_fbFFTBlk.mhWinHdl);
	}

	/////////////////////////////////////////////////////////////////////////
	// Lock FFT filter transfer buffer
	/////////////////////////////////////////////////////////////////////////
	if (NULL == (lpXfrBuf = (LPCPXF) GloMemLck (m_fbFFTBlk.mhXfrHdl))) {
		CIFDspRes (MB_OKCANCEL, IDS_DTMALGERR);
		return;
	}

	/////////////////////////////////////////////////////////////////////////
	// Zero complex transfer function at notch frequency
	/////////////////////////////////////////////////////////////////////////
	for (usi = 0; usi < nfDTMF.usFrqCnt; usi++) {
		if (nfDTMF.ulNchFrq[usi] < ulSmpFrq/2L) {
			DWORD ulFrqBin = (m_fbFFTBlk.ulFFTPts * nfDTMF.ulNchFrq[usi]) / (ulSmpFrq/2L);
			if (ulFrqBin >= 2) {
				lpXfrBuf[ulFrqBin-2].flRea *= (float) (1 - HAMWIN (7, 1));
				lpXfrBuf[ulFrqBin-2].flImg *= (float) (1 - HAMWIN (7, 1));
			}
			if (ulFrqBin >= 1) {
				lpXfrBuf[ulFrqBin-1].flRea *= (float) (1 - HAMWIN (7, 2));
				lpXfrBuf[ulFrqBin-1].flImg *= (float) (1 - HAMWIN (7, 2));
			}
			lpXfrBuf[ulFrqBin].flRea = 0;
			lpXfrBuf[ulFrqBin].flImg = 0;
			if ((ulFrqBin+1) < m_fbFFTBlk.ulFFTPts) {
				lpXfrBuf[ulFrqBin+1].flRea *= (float) (1 - HAMWIN (7, 4));
				lpXfrBuf[ulFrqBin+1].flImg *= (float) (1 - HAMWIN (7, 4));
			}
			if ((ulFrqBin+2) < m_fbFFTBlk.ulFFTPts) {
				lpXfrBuf[ulFrqBin+2].flRea *= (float) (1 - HAMWIN (7, 5));
				lpXfrBuf[ulFrqBin+2].flImg *= (float) (1 - HAMWIN (7, 5));
			}
		}
	}

	/////////////////////////////////////////////////////////////////////////
	// Convert infinite length transfer functions into valid frequency
	// domain filter. Unlock transfer buffer memory.
	/////////////////////////////////////////////////////////////////////////
	EffWinRsp (EFFWINHAM, lpXfrBuf, m_fbFFTBlk.ulFFTPts); 
	GloMemUnL (m_fbFFTBlk.mhXfrHdl);

	/////////////////////////////////////////////////////////////////////////
	// Indicate algorithm type, exit
	/////////////////////////////////////////////////////////////////////////
	m_usDTMAlg = usDTMAlg;
	return;

}

CAudEff	*	CEffDTM::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	// Filter according to algorithm type
	/////////////////////////////////////////////////////////////////////////
	switch (m_usDTMAlg) {
		case DTMALGFFT:
			EffFFTFtr (pAudEff->GetEBSBlk(), &m_ebEBSBlk, &m_fbFFTBlk, 
				(EFFFFTCBK) FrqEffCBk, this);
			break;
		default:
			EffEBStoE (pAudEff->GetEBSBlk(), &m_ebEBSBlk, (DWORD) -1L);
	}
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

CEffDTM::~CEffDTM ()
{
	/////////////////////////////////////////////////////////////////////////
	// Release FFT filter block; constructor inits for safe release
	/////////////////////////////////////////////////////////////////////////
	EffFFTRel (&m_fbFFTBlk);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffRes::CEffRes (DWORD ulSrcFrq, DWORD ulDstFrq, RESALG usResAlg)
{
	float	flResRat;

	/////////////////////////////////////////////////////////////////////////
	// Initialize Resample & FFT blocks to insure safe destructor release
	/////////////////////////////////////////////////////////////////////////
	EffResSet (&m_rbResBlk);
	memset (&m_fbFFTBlk, 0, sizeof (m_fbFFTBlk));
	memset (&m_ebEBSFFT, 0, sizeof (m_ebEBSFFT));

	/////////////////////////////////////////////////////////////////////////
	// Set destination frequency and resample algorithm
	/////////////////////////////////////////////////////////////////////////
	m_ulDstFrq = ulDstFrq;
	m_usResAlg = usResAlg;
	
	/////////////////////////////////////////////////////////////////////////
	// Exit if not FFT based resample algorithm
	/////////////////////////////////////////////////////////////////////////
	if (RESALGFFT != m_usResAlg) return;

	/////////////////////////////////////////////////////////////////////////
	// Reset to linear resampling if source frequency is unknown, or if
	// the resample ratio is <= 1 (indicating decimation)
	/////////////////////////////////////////////////////////////////////////
	if (!ulSrcFrq || ((flResRat = ulDstFrq / (float) ulSrcFrq) <= 1)) {
		m_usResAlg = RESALGNRM;
		return;
	}
	flResRat = (float) ceil (flResRat);	

	/////////////////////////////////////////////////////////////////////////
	// Initialize FFT block
	/////////////////////////////////////////////////////////////////////////
	if (EffFFTAlo (FFTORDDEF, flResRat, &m_fbFFTBlk, (EFFPOLPRC) NULL, 0L)) {
		CIFDspRes (MB_OKCANCEL, IDS_RESALGERR);
		m_usResAlg = RESALGNON;
		return;
	}	

//	float  *lpWinBuf;
//	/////////////////////////////////////////////////////////////////////////
//	// Lock data window memory, initialize
//	// Note: Data window is twice the FFT point size - overlap saved
//	/////////////////////////////////////////////////////////////////////////
//	if (NULL != (lpWinBuf = (float FAR *) GloMemLck (m_fbFFTBlk.mhWinHdl))) {
//		EffWinGen (EFFWINTAP, lpWinBuf, 2 * m_fbFFTBlk.ulFFTPts);
//		GloMemUnL (m_fbFFTBlk.mhWinHdl);
//	}

//	LPCPXF  lpXfrBuf;
//	/////////////////////////////////////////////////////////////////////////
//	// Convert infinite length transfer functions into valid frequency
//	// domain filter. Lock FFT filter transfer buffer & window.
//	/////////////////////////////////////////////////////////////////////////
//	if (NULL != (lpXfrBuf = (LPCPXF) GloMemLck (m_fbFFTBlk.mhXfrHdl))) {
//		EffWinRsp (EFFWINHAM, lpXfrBuf, m_fbFFTBlk.ulFFTPts); 
//		GloMemUnL (m_fbFFTBlk.mhXfrHdl);
//	}

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	return;

}

CEffRes::~CEffRes ()
{
	/////////////////////////////////////////////////////////////////////////
	// Release FFT filter block; constructor inits for safe release
	/////////////////////////////////////////////////////////////////////////
	GloAloRel (m_ebEBSFFT.mhBufHdl);
	EffFFTRel (&m_fbFFTBlk);
}

CAudEff	*	CEffRes::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	// Resample according to algorithm type
	/////////////////////////////////////////////////////////////////////////
	switch (m_usResAlg) {
		case RESALGNRM:
			EffFrqRes (pAudEff->GetEBSBlk(), &m_ebEBSBlk, m_ulDstFrq, &m_rbResBlk);
			break;
		case RESALGFFT:
			EffFFTFtr (pAudEff->GetEBSBlk(), &m_ebEBSFFT, &m_fbFFTBlk, 
				(EFFFFTCBK) FrqEffCBk, this);
			EffFrqRes (&m_ebEBSFFT, &m_ebEBSBlk, m_ulDstFrq, &m_rbResBlk);
			break;
		default:
			EffEBStoE (pAudEff->GetEBSBlk(), &m_ebEBSBlk, (DWORD) -1L);
	}
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

DWORD		CEffRes::SrcSizEst (DWORD ulDstSmp, DWORD ulSrcFrq)
{
	if (RESALGNON == m_usResAlg) return (ulDstSmp);
	else return (EffResSSz (ulDstSmp, ulSrcFrq, m_ulDstFrq, &m_rbResBlk));
}

DWORD		CEffRes::DstSizEst (DWORD ulSrcSmp, DWORD ulSrcFrq)
{
	if (RESALGNON == m_usResAlg) return (ulSrcSmp);
	else return (EffResDSz (ulSrcSmp, ulSrcFrq, m_ulDstFrq, &m_rbResBlk));
}

float		CEffRes::SmpToMSec (DWORD ulSmpPos)
{
	if (!m_ulDstFrq) return (0L);
	/////////////////////////////////////////////////////////////////////////
	// Convert samples to millisec
	/////////////////////////////////////////////////////////////////////////
	return (1000L * (ulSmpPos / (float) m_ulDstFrq));
}


