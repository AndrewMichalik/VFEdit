/////////////////////////////////////////////////////////////////////////////
// EffEqu.cpp : Implementation of the CAudEff equalizer classes
// Copyright (c) 1987-1996 Andrew J. Michalik
/////////////////////////////////////////////////////////////////////////////
#include "gencif.h"						// Generic C I/F application defs

#include "audfil.h"						// Audio file support defs
#include "audeff.h"						// Audio effects support defs

extern "C"
{
	#include <math.h>					// Math library defs
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffEqu::CEffEqu (WORD usFFTOrd, DWORD ulSmpFrq, WORD usEquBnd, 
				float FAR *lpEquArr, float flEquGai) 
{
	float  *lpWinBuf;
	LPCPXF  lpXfrBuf;

	/////////////////////////////////////////////////////////////////////////
	// Initialize FFT block; allocate inits for safe destructor release
	/////////////////////////////////////////////////////////////////////////
	if (EffFFTAlo (usFFTOrd, 1, &m_fbFFTBlk, (EFFPOLPRC) NULL, 0L)) {
		CIFDspRes (MB_OKCANCEL, IDS_EQUALOERR);
		return;
	}	

	/////////////////////////////////////////////////////////////////////////
	// Lock data window memory, initialize
	// Note: Data window is twice the FFT point size - overlap saved
	/////////////////////////////////////////////////////////////////////////
	if (NULL != (lpWinBuf = (float FAR *) GloMemLck (m_fbFFTBlk.mhWinHdl))) {
		EffWinGen (EFFWINTAP, lpWinBuf, 2 * m_fbFFTBlk.ulFFTPts);
		GloMemUnL (m_fbFFTBlk.mhWinHdl);
	}

//    float   flWinNrm = 0;
//        flWinNrm += lpWinBuf[usi];
//    /********************************************************************/
//    /* Normalize new window for unity gain                              */
//    /* Note: Window sharpens impulse response, should gain be reduced?  */
//    /********************************************************************/
//    if (flWinNrm > 0) for (usi = 0; usi < usWinLen; usi++) 
//        lpWinBuf[usi] /= (flWinNrm / usWinLen);

	/////////////////////////////////////////////////////////////////////////
	// Allocate equalizer variables; adjust input filter
	/////////////////////////////////////////////////////////////////////////
	if (EffEquAlo (0L, ulSmpFrq / 2L, ulSmpFrq, usEquBnd, lpEquArr, flEquGai,
		&m_fbFFTBlk)) {
		CIFDspRes (MB_OKCANCEL, IDS_EQUALOERR);
		return;
	}

	/////////////////////////////////////////////////////////////////////////
	// Convert infinite length transfer functions into valid frequency
	// domain filter. Lock FFT filter transfer buffer & window.
	/////////////////////////////////////////////////////////////////////////
	if (NULL != (lpXfrBuf = (LPCPXF) GloMemLck (m_fbFFTBlk.mhXfrHdl))) {
		EffWinRsp (EFFWINHAM, lpXfrBuf, m_fbFFTBlk.ulFFTPts); 
		GloMemUnL (m_fbFFTBlk.mhXfrHdl);
	}

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	return;

}

CAudEff	*	CEffEqu::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	EffFFTFtr (pAudEff->GetEBSBlk(), &m_ebEBSBlk, &m_fbFFTBlk, 
		(EFFFFTCBK) FrqEffCBk, this);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

CEffEqu::~CEffEqu ()
{
	/////////////////////////////////////////////////////////////////////////
	EffEquRel (&m_fbFFTBlk);
	EffFFTRel (&m_fbFFTBlk);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
WORD CALLBACK EXPORT CEffPow::PowPolCBk (EFFPOL usPolReq, DWORD ulFilPos, 
										 CEffPow FAR *lpEffPow)
{
	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	if (!lpEffPow || !lpEffPow->m_fpFIOCBk) return (TRUE);

	/////////////////////////////////////////////////////////////////////////
	// Call main poll procedure with sum progress values.
	// Inhibit sub-poll multiple EFFPOLBEG and EFFPOLEND calls.
	// Note: Constructor / destructor handle FIOPOLBEG and FIOPOLEND.
	/////////////////////////////////////////////////////////////////////////
	switch (usPolReq) {
		case EFFPOLCNT:
			return (lpEffPow->m_fpFIOCBk (FIOPOLCNT, lpEffPow->m_bpPowBlk.ulSetOut, lpEffPow->m_ulCBkDat));
		case EFFPOLPOS:
			return (lpEffPow->m_fpFIOCBk (FIOPOLPOS, lpEffPow->m_bpPowBlk.ulSetOut, lpEffPow->m_ulCBkDat));
	}
	return (TRUE);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
WORD CALLBACK EXPORT CEffPow::EffPowCBk (float FAR * FAR *ppflSrcBuf, 
				DWORD FAR *lpulDstCnt, DWORD ulBufPts, DWORD ulTotPts, 
				DWORD ulHdrPts, DWORD ulCtrPts, DWORD ulDstRem, LPFFTB lpFFTBlk)
{
	POWBLK FAR *lpPowBlk = (POWBLK FAR *) lpFFTBlk->lpUsrDat;
	CPXFLT FAR *lpFFTCpx = (CPXFLT FAR *)(*ppflSrcBuf);
	float		*lpWinBuf;
	float		*lpXfrBuf;
	DWORD		uli;
			   	
	/////////////////////////////////////////////////////////////////////////
	// The EffFFTFtr (calling routine) delivers a set of data points where
	// ulCtrPts at offset ulHdrPts have been correctly isolated to implement
	// the overlap-save method of FFT corruption prevention.
	/////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////
	// Default returned data count to zero
	/////////////////////////////////////////////////////////////////////////
	*lpulDstCnt = 0L;

	/////////////////////////////////////////////////////////////////////////
	// Completion pass?	Indicate done processing...
	/////////////////////////////////////////////////////////////////////////
	if (!ulCtrPts) return (FALSE);

	/////////////////////////////////////////////////////////////////////////
	// Lock data window buffer
	// Apply data window (already normalized for A to D range, percent, etc)
	/////////////////////////////////////////////////////////////////////////
	if (NULL != (lpWinBuf = (float FAR *) GloMemLck (lpFFTBlk->mhWinHdl))) {
		for (uli = 0L; uli < ulTotPts; uli++) (*ppflSrcBuf)[uli] *= lpWinBuf[uli];
		GloMemUnL (lpFFTBlk->mhWinHdl);
	}

	/////////////////////////////////////////////////////////////////////////
	// Transform to frequency domain
	/////////////////////////////////////////////////////////////////////////
	EffFFTRea (*ppflSrcBuf, (WORD) (ulTotPts / 2L), EFFFFTFWD);

	/////////////////////////////////////////////////////////////////////////
	// Unfold Nyquist frequency into next highest slot
	/////////////////////////////////////////////////////////////////////////
	(*ppflSrcBuf)[ulTotPts - 1] += (*ppflSrcBuf)[1];
	(*ppflSrcBuf)[1] = 0;

	/////////////////////////////////////////////////////////////////////////
	// Lock FFT filter transfer buffer
	/////////////////////////////////////////////////////////////////////////
	if (NULL == (lpXfrBuf = (float FAR *) GloMemLck (lpFFTBlk->mhXfrHdl))) 
		return (FALSE);

	/////////////////////////////////////////////////////////////////////////
	// Sum into power spectrum array
	/////////////////////////////////////////////////////////////////////////
	for (uli = 0L; uli < ulTotPts / 2L; uli++) {
		#define SQR(a) ((a)*(a))
		lpXfrBuf[uli] += (float) sqrt (SQR (lpFFTCpx[uli].flRea) 
			+ SQR(lpFFTCpx[uli].flImg));
	}

	/////////////////////////////////////////////////////////////////////////
	// Sum set complete?	
	// Calculate comparison to dither output by one set.
	/////////////////////////////////////////////////////////////////////////
	if (++lpPowBlk->ulCurSum >= (lpPowBlk->flSetSiz * (1 + lpPowBlk->ulSetOut))) {
		/////////////////////////////////////////////////////////////////////
		// Compute normalized divisor based on sums since last output
		/////////////////////////////////////////////////////////////////////
		DWORD	ulDthDiv = lpPowBlk->ulCurSum 
				- (DWORD) ceil (lpPowBlk->flSetSiz * lpPowBlk->ulSetOut);

		/////////////////////////////////////////////////////////////////////
		// Copy power spectrum array to output buffer and normalize
		// Zero power spectrum array for next set
		// Adjust for data window attentuation
		/////////////////////////////////////////////////////////////////////
		for (uli = 0; uli < lpFFTBlk->ulFFTPts; uli++) {
			(*ppflSrcBuf)[uli] = lpXfrBuf[uli] / ulDthDiv;
			lpXfrBuf[uli] = 0;
		}
		lpPowBlk->ulSetOut++;

		/////////////////////////////////////////////////////////////////////
		// Indicate number of valid output samples and continue processing
		/////////////////////////////////////////////////////////////////////
		*lpulDstCnt = lpFFTBlk->ulFFTPts;
	}	

	/////////////////////////////////////////////////////////////////////////
	// Unlock FFT filter transfer buffer
	/////////////////////////////////////////////////////////////////////////
	GloMemUnL (lpFFTBlk->mhXfrHdl);

	/////////////////////////////////////////////////////////////////////////
	// Return TRUE to continue processing
	/////////////////////////////////////////////////////////////////////////
	return (TRUE);

}

CEffPow::CEffPow (WORD usFFTOrd, float flSetSiz, DWORD ulTimPnt, 
				DWORD ulAtDMax, FIOPOLPRC fpFIOCBk, DWORD ulCBkDat)
{
	#define	POWPCTMUL	100
	float *	lpWinBuf;
	float *	lpXfrBuf;
	DWORD	uli;

	/////////////////////////////////////////////////////////////////////////
	// Initialize power spectrum sum variables
	/////////////////////////////////////////////////////////////////////////
	m_bpPowBlk.flSetSiz = flSetSiz;
	m_bpPowBlk.ulTimPnt = ulTimPnt;
	m_bpPowBlk.ulCurSum = 0;
	m_bpPowBlk.ulSetOut = 0;

	/////////////////////////////////////////////////////////////////////////
	// Initialize sub-poll callback procedure
	/////////////////////////////////////////////////////////////////////////
	m_fpFIOCBk = fpFIOCBk;
	m_ulCBkDat = ulCBkDat;

	/////////////////////////////////////////////////////////////////////////
	// Notify poll procedure that operation is beginning
	// Note: Destructor always calls poll routine with FIOPOLEND
	/////////////////////////////////////////////////////////////////////////
	if (m_fpFIOCBk) m_fpFIOCBk (FIOPOLBEG, m_bpPowBlk.ulTimPnt, m_ulCBkDat);
		
	/////////////////////////////////////////////////////////////////////////
	// Initialize FFT block; allocate inits for safe destructor release
	/////////////////////////////////////////////////////////////////////////
	if (EffFFTAlo (usFFTOrd, 1, &m_fbFFTBlk, (EFFPOLPRC) PowPolCBk, (DWORD) this)) {
		CIFDspRes (MB_OKCANCEL, IDS_POWALOERR);
		m_bpPowBlk.flSetSiz = 0;
		return;
	}	

	/////////////////////////////////////////////////////////////////////////
	// Lock data window memory, initialize
	// Note: Data window is twice the FFT point size - overlap saved
	/////////////////////////////////////////////////////////////////////////
	if (NULL != (lpWinBuf = (float FAR *) GloMemLck (m_fbFFTBlk.mhWinHdl))) {
		float	flWinNrm = 0;
		/////////////////////////////////////////////////////////////////////
		// Create data window and calculate power attenuation
		// Normalize for power attenuation
		// Normalize for A to D range
		// Normalize for percentage
		/////////////////////////////////////////////////////////////////////
		EffWinGen (EFFWINTRI, lpWinBuf, 2 * m_fbFFTBlk.ulFFTPts);
		for (uli = 0; uli < 2 * m_fbFFTBlk.ulFFTPts; uli++) flWinNrm += lpWinBuf[uli];
		if (flWinNrm *= ulAtDMax / (float) (POWPCTMUL * 2 * m_fbFFTBlk.ulFFTPts)) 
			for (uli = 0; uli < 2 * m_fbFFTBlk.ulFFTPts; uli++) lpWinBuf[uli] /= flWinNrm;
		GloMemUnL (m_fbFFTBlk.mhWinHdl);
	}
	else m_bpPowBlk.flSetSiz = 0;

	/////////////////////////////////////////////////////////////////////////
	// Lock spectrum sum memory (uses transfer function memory), initialize
	/////////////////////////////////////////////////////////////////////////
	if (NULL != (lpXfrBuf = (float FAR *) GloMemLck (m_fbFFTBlk.mhXfrHdl))) {
		for (uli = 0; uli < m_fbFFTBlk.ulFFTPts; uli++) lpXfrBuf[uli] = 0;
		GloMemUnL (m_fbFFTBlk.mhXfrHdl);
	}
	else m_bpPowBlk.flSetSiz = 0;

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	return;

}

CAudEff	*	CEffPow::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	// Exit if initializations failed
	/////////////////////////////////////////////////////////////////////////
	if (!m_bpPowBlk.flSetSiz) return (this);

	/////////////////////////////////////////////////////////////////////////
	EffFFTFtr (pAudEff->GetEBSBlk(), &m_ebEBSBlk, &m_fbFFTBlk, 
		(EFFFFTCBK) EffPowCBk, &m_bpPowBlk);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

DWORD	CEffPow::Write (WORD *pusPltArr, DWORD ulTimCnt)
{
	/////////////////////////////////////////////////////////////////////////
	// Return number plot time points written
	/////////////////////////////////////////////////////////////////////////
	return (EffEBStoM (&m_ebEBSBlk, m_fbFFTBlk.ulFFTPts * ulTimCnt, pusPltArr, -1L,
		MPCPCM016, PCMBIODEF, NULL, (EBSMWRPRC) PCMG16toP)
		/ (m_fbFFTBlk.ulFFTPts * PCMSmp2Bh (MPCPCM016, 1, 1, NULL)));	 
}

CEffPow::~CEffPow ()
{
	/////////////////////////////////////////////////////////////////////////
	// Notify poll procedure that operation is ending
	/////////////////////////////////////////////////////////////////////////
	if (m_fpFIOCBk) m_fpFIOCBk (FIOPOLEND, m_bpPowBlk.ulTimPnt, m_ulCBkDat);

	/////////////////////////////////////////////////////////////////////////
	EffFFTRel (&m_fbFFTBlk);
}
