/////////////////////////////////////////////////////////////////////////////
// AudEff.cpp : Implementation of the CAudEff classes
// Copyright (c) 1987-1996 Andrew J. Michalik
/////////////////////////////////////////////////////////////////////////////
#include "gencif.h"						// Generic C I/F application defs

#include "audfil.h"						// Audio file support defs
#include "audeff.h"						// Audio effects support defs

extern "C"
{
	#include <math.h>					// Math library defs
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DWORD 		CAudEff::Wr_PtoEBS (LPVOID lpSrcBuf, DWORD *pulBytRem, DWORD ulSmpCnt, 
				PCMTYP usSrcPCM, WORD usEncMsk, LPITCB lpITCBlk)
{
	/////////////////////////////////////////////////////////////////////////
	// Write to EBS & convert from input PCM format; return sample count
	// Note: This routine is not guaranteed to read the complete input
	//		 memory stream. Check return *lpulBytRem for remainder
	/////////////////////////////////////////////////////////////////////////
	return (EffMtoEBS (lpSrcBuf, pulBytRem, GetEBSBlk(), ulSmpCnt, usSrcPCM, 
		GetEBSBlk()->usChnCnt, usEncMsk, GetEBSBlk()->ulSmpFrq, lpITCBlk,
		(EBSMRDPRC) PCMPtoG16));
}

DWORD		CAudEff::Rd_EBStoP (LPVOID lpDstBuf, DWORD ulBufSiz, DWORD ulSmpCnt, 
				PCMTYP usDstPCM, WORD usEncMsk, LPITCB lpITCBlk)
{
	/////////////////////////////////////////////////////////////////////////
	// Read from EBS & convert to output PCM format; return byte count
	/////////////////////////////////////////////////////////////////////////
	return (EffEBStoM (GetEBSBlk(), ulSmpCnt, lpDstBuf,	ulBufSiz,
          usDstPCM, usEncMsk, lpITCBlk, (EBSMWRPRC) PCMG16toP));
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffInp::CEffInp(CAudFil *pAudFil)	
{
	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	m_pAudFil  = pAudFil;

	/////////////////////////////////////////////////////////////////////////
	// Allocate work memory in multiples of PCMBLKSIZ, initialize
	/////////////////////////////////////////////////////////////////////////
	if (NULL == (m_hgWrkHdl = GloAloBlk (GMEM_MOVEABLE, PCMBLKSIZ, PCMMINCNT, 
	  PCMMAXCNT, &m_ulWrkSiz))) {
		m_hgWrkHdl = NULL;
		m_ulWrkSiz = 0L;
	}

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	return;

}

CEffInp::~CEffInp()	
{
	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	GloAloRel (m_hgWrkHdl);
	Close();
}

BOOL		CEffInp::Open (UINT nOpenFlags, DWORD ulSmpOff, DWORD ulSmpCnt, DWORD ulLopCnt)
{
	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	if (!m_pAudFil) return (FALSE);

	/////////////////////////////////////////////////////////////////////////
	DWORD	ulFilLen = m_pAudFil->GetSmpCnt();

	/////////////////////////////////////////////////////////////////////////
	m_ulSmpOff = min (ulSmpOff, ulFilLen);
	m_ulSmpTot = min (ulSmpCnt, ulFilLen);
	m_ulLopCnt = ulLopCnt; 

	/////////////////////////////////////////////////////////////////////////
	// Limit sample count; (assume file opened for input only)
	/////////////////////////////////////////////////////////////////////////
	m_ulSmpRem = min (m_ulSmpTot, ulFilLen - m_ulSmpOff); 
	m_ulLopRem = m_ulLopCnt; 

	/////////////////////////////////////////////////////////////////////////
	// Open and set new audio file
	/////////////////////////////////////////////////////////////////////////
	if (!m_pAudFil->Open(nOpenFlags)) return (FALSE);
	m_ulSmpOff = m_pAudFil->Seek(m_ulSmpOff);

	/////////////////////////////////////////////////////////////////////////
	return (TRUE);
}

DWORD	CEffInp::Seek (DWORD ulPosVec)
{
	/////////////////////////////////////////////////////////////////////////
	// Seek relative to the audio file m_ulSmpOff
	/////////////////////////////////////////////////////////////////////////
	ulPosVec = min (ulPosVec, m_ulSmpTot);
	m_ulSmpRem = min (m_ulSmpTot, m_ulSmpTot - ulPosVec); 

	/////////////////////////////////////////////////////////////////////////
	// Return sample adjusted position vector	
	/////////////////////////////////////////////////////////////////////////
	if (-1L == (ulPosVec = m_pAudFil->Seek(m_ulSmpOff + ulPosVec))) return (-1L);
	return (ulPosVec - m_ulSmpOff);
}

DWORD	CEffInp::Read (LPBYTE lpDstBuf, DWORD ulBufSiz)
{
	DWORD	ulSmpInp;
	DWORD	ulBytOut;

	/////////////////////////////////////////////////////////////////////////
	// Raw mode requested: simply transfer raw PCM to buffer
	/////////////////////////////////////////////////////////////////////////
	ulSmpInp = m_pAudFil->Read (lpDstBuf, ulBufSiz, m_ulSmpRem, &ulBytOut, TRUE);
	if (-1L == ulSmpInp) return (0L);

	/////////////////////////////////////////////////////////////////////////
	// Restart buffer sample I/O if input empty & loop count > 0
	/////////////////////////////////////////////////////////////////////////
	if (!ulSmpInp && m_ulLopCnt) {
		DWORD	ulFilLen = m_pAudFil->GetSmpCnt();
		m_pAudFil->Seek(m_ulSmpOff);
		m_ulSmpRem = (m_ulSmpOff >= ulFilLen) ? 0L : min (m_ulSmpTot, ulFilLen - m_ulSmpOff); 
		ulSmpInp = m_pAudFil->Read (lpDstBuf, ulBufSiz, m_ulSmpRem, &ulBytOut, TRUE);
	}
	
	/////////////////////////////////////////////////////////////////////////
	// Duplicate looped small sections for smooth playback.
	// Sample request rounding SmpSmpLow() assures that a full read will
	// occur on the first pass with a small sample count.
	// Note: Should actually re-compute first raw dup with new ITCBlk.
	/////////////////////////////////////////////////////////////////////////
	if (m_ulLopCnt && ulSmpInp && (ulSmpInp >= m_pAudFil->SmpSmpLow (m_ulSmpTot))) {
		DWORD 	ulOrgByt = ulBytOut;
		while (m_ulLopCnt && ((ulBytOut + ulOrgByt) <= ulBufSiz)) {
			hmemcpy (&((BYTE huge *)lpDstBuf)[ulBytOut], lpDstBuf, ulOrgByt);
			ulBytOut += ulOrgByt;
			m_ulLopCnt--;
		}
	}

	/////////////////////////////////////////////////////////////////////////
	// Force samples remaining to zero if no samples input
	/////////////////////////////////////////////////////////////////////////
	m_ulSmpRem -= ulSmpInp ? ulSmpInp : m_ulSmpRem;

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	return (ulBytOut);

}

CAudEff	*	CEffInp::ExeEffPrc (CAudEff *pNulPtr)
{
	DWORD		ulSmpInp;

	/////////////////////////////////////////////////////////////////////////
	// Read input file if any file samples are remaining
	/////////////////////////////////////////////////////////////////////////
	ulSmpInp = m_pAudFil->Read (this, m_ulSmpRem);
	if (-1L == ulSmpInp) return (0L);

	/////////////////////////////////////////////////////////////////////////
	// Restart buffer sample I/O if input empty & loop count > 0
	/////////////////////////////////////////////////////////////////////////
	if (!ulSmpInp && m_ulLopCnt) {
		DWORD	ulFilLen = m_pAudFil->GetSmpCnt();
		m_pAudFil->Seek(m_ulSmpOff);
		m_ulSmpRem = (m_ulSmpOff >= ulFilLen) ? 0L : min (m_ulSmpTot, ulFilLen - m_ulSmpOff); 
		ulSmpInp = m_pAudFil->Read (this, m_ulSmpRem);
	}

	/////////////////////////////////////////////////////////////////////////
	// Duplicate looped small sections for smooth playback.
	// Round sample request down to get full read; this permits small 
	// duplicated loop blocks for odd PCM bytes. 
	// Note: Destination uses generic samples and does not require ITCBlk
	/////////////////////////////////////////////////////////////////////////
	if (m_ulLopCnt && ulSmpInp && (ulSmpInp >= m_pAudFil->SmpSmpLow(m_ulSmpTot))) {
		LPEBSB	lpDstEBS = GetEBSBlk();
		LPVOID	lpDstBuf;
		/////////////////////////////////////////////////////////////////////
		if (NULL != (lpDstBuf = GloMemLck (lpDstEBS->mhBufHdl))) {
			DWORD	ulBufSiz = GloMemSiz (lpDstEBS->mhBufHdl);
			DWORD 	ulBytOut = PCMSmp2Bh (lpDstEBS->usPCMTyp, 
					lpDstEBS->usChnCnt, lpDstEBS->ulSmpCnt, NULL);	 
			DWORD	ulOrgByt = ulBytOut;
			DWORD	ulOrgSmp = lpDstEBS->ulSmpCnt;
			while (m_ulLopCnt && ((ulBytOut + ulOrgByt) <= ulBufSiz)) {
				hmemcpy (&((BYTE huge *)lpDstBuf)[ulBytOut], lpDstBuf, ulOrgByt);
				lpDstEBS->ulSmpCnt += ulOrgSmp;
				ulBytOut += ulOrgByt;
				m_ulLopCnt--;
			}
	        GloMemUnL (lpDstEBS->mhBufHdl);
		}
	}

	/////////////////////////////////////////////////////////////////////////
	// Force samples remaining to zero if no samples input
	/////////////////////////////////////////////////////////////////////////
	m_ulSmpRem -= ulSmpInp ? ulSmpInp : m_ulSmpRem;

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

void		CEffInp::Close ()
{
	if (m_pAudFil) m_pAudFil->Close();
}

DWORD		CEffInp::GetSmpTot ()
{
	return (m_ulSmpTot);
}

DWORD		CEffInp::GetSmpRem ()
{
	return (m_ulSmpRem);
}

DWORD		CEffInp::GetSmpOff ()
{
	return (m_ulSmpOff);
}

float		CEffInp::SmpToMSec (DWORD ulSmpPos)
{
	/////////////////////////////////////////////////////////////////////////
	// Convert samples to millisec
	/////////////////////////////////////////////////////////////////////////
	return (m_pAudFil ? m_pAudFil->SmpToMSec (ulSmpPos) : 0L);
}

DWORD		CEffInp::MSecToSmp (float flTimPos)
{
	/////////////////////////////////////////////////////////////////////////
 	// Convert millisec to samples
	/////////////////////////////////////////////////////////////////////////
	return (m_pAudFil ? m_pAudFil->MSecToSmp (flTimPos) : 0L);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffChn::CEffChn (WORD usDstChn)
{
	m_usDstChn = usDstChn;
}

DWORD		CEffChn::SrcSizEst (DWORD ulDstSmp, WORD usSrcChn)
{
	return (EffChnSSz (ulDstSmp, usSrcChn, m_usDstChn));
}

DWORD		CEffChn::DstSizEst (DWORD ulSrcSmp, WORD usSrcChn)
{
	return (EffChnDSz (ulSrcSmp, usSrcChn, m_usDstChn));
}

CAudEff	*	CEffChn::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	// Mix or separate channels
	/////////////////////////////////////////////////////////////////////////
	EffChXtoM (pAudEff->GetEBSBlk(), &m_ebEBSBlk, pAudEff->GetEBSBlk()->usChnCnt);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffAtD::CEffAtD (PCMTYP usDstPCM)
{
	m_usDstAtD = (WORD) PCMCapQry (usDstPCM, ATDRESQRY, 0L);
}

CAudEff	*	CEffAtD::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	// Normalize for output A to D resolution
	/////////////////////////////////////////////////////////////////////////
	EffVolAtD (pAudEff->GetEBSBlk(), &m_ebEBSBlk, m_usDstAtD);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

CEffAtD::~CEffAtD ()
{
    if (m_ebEBSBlk.mhBufHdl) GloAloRel (m_ebEBSBlk.mhBufHdl);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffDCE::CEffDCE (WORD usSrcPCM, WORD usSrcChn, DWORD ulSrcFrq, float flCmpThr, 
				DWORD ulCmpAtk, float flCmpMin, float flExpThr, DWORD ulExpAtk, 
				float flExpMax, DWORD ulCE_Dcy, float flNoiThr, float flNoiAtt)
{
	/////////////////////////////////////////////////////////////////////////
	// Initialize / allocate Dynamic Compressor/Expander block
	/////////////////////////////////////////////////////////////////////////
	if (EffDCEAlo (usSrcPCM, usSrcChn, ulSrcFrq, flCmpThr, ulCmpAtk, flCmpMin,
		flExpThr, ulExpAtk, flExpMax, ulCE_Dcy, flNoiThr, flNoiAtt, &m_dbDCEBlk))
		CIFDspRes (MB_OKCANCEL, IDS_DCEALOERR);

}

CAudEff	*	CEffDCE::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	EffVolDCE (pAudEff->GetEBSBlk(), &m_ebEBSBlk, &m_dbDCEBlk);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffEch::CEffEch (WORD usEchAlg, DWORD ulDlySmp, float flDec_dB)
{
	if (EffEchAlo (usEchAlg, ulDlySmp, flDec_dB, &m_ebEchBlk)) 
		CIFDspRes (MB_OKCANCEL, IDS_ECHALOERR);
}

CAudEff	*	CEffEch::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	EffEchDec (pAudEff->GetEBSBlk(), &m_ebEBSBlk, &m_ebEchBlk);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffFad::CEffFad (WORD usFadAlg, float flFadBeg, float flFadEnd, DWORD ulSmpCnt)
{
	if (EffFadAlo (usFadAlg, flFadBeg, flFadEnd, ulSmpCnt, &m_fbFadBlk)) 
		CIFDspRes (MB_OKCANCEL, IDS_FADALOERR);
}

CAudEff	*	CEffFad::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	EffFad_IO (pAudEff->GetEBSBlk(), &m_ebEBSBlk, &m_fbFadBlk);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffNoi::CEffNoi (float flMutThr, float flAtt_dB, PCMTYP usSrcPCM, WORD usNoiAlg)	
{
	m_ulMutThr = (DWORD) (flMutThr * PCMCapQry (usSrcPCM, ATDMAXQRY, 0L));
	m_flAtt_dB = flAtt_dB;
}

CAudEff	*	CEffNoi::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	EffNoiRed (pAudEff->GetEBSBlk(), &m_ebEBSBlk, m_ulMutThr, m_flAtt_dB);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CAudEff	*	CEffVol::ExeEffPrc (CAudEff *pAudEff)
{
	/////////////////////////////////////////////////////////////////////////
	EffVolAdj (pAudEff->GetEBSBlk(), &m_ebEBSBlk, m_flLvl_dB);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	return (this);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffTon::CEffTon (TONBLK *pSigArr, WORD usSigCnt, float flTimLen, 
				DWORD ulAtDMax, DWORD ulSmpFrq)
{
	WORD	usi;

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	m_pSigArr = pSigArr;
	m_usSigCnt = usSigCnt;
	m_ulSmpCnt = (DWORD) (flTimLen * ulSmpFrq);
	m_ulSigPos = 0L;
	m_ulBytRem = 0L;

	/////////////////////////////////////////////////////////////////////////
	// Note: should probably re-design tone generation in future release
	/////////////////////////////////////////////////////////////////////////
	m_ebEBSBlk.ulSmpFrq = ulSmpFrq;
	m_ebEBSBlk.usChnCnt = 1;

	/////////////////////////////////////////////////////////////////////////
	// Convert frequency values to radians / sample
	// Convert percent amplitude to full range gain values
	/////////////////////////////////////////////////////////////////////////
	for (usi = 0; usi < m_usSigCnt; usi++) {
        pSigArr[usi].flSigFrq *= (float) (db2PI / ulSmpFrq);
		pSigArr[usi].flSigAmp *= ulAtDMax / (float) (m_usSigCnt * 100);
	}

	/////////////////////////////////////////////////////////////////////////
	// Allocate work memory in multiples of PCMBLKSIZ, initialize
	/////////////////////////////////////////////////////////////////////////
	if (NULL == (m_hgWrkHdl = GloAloBlk (GMEM_MOVEABLE, PCMBLKSIZ, PCMMINCNT, 
	  PCMMAXCNT, &m_ulWrkSiz))) {
		m_hgWrkHdl = NULL;
		m_ulWrkSiz = 0L;
	}

	/////////////////////////////////////////////////////////////////////////
	return;

}

CAudEff	*	CEffTon::ExeEffPrc (CAudEff *pAudEff)
{
	GENSMP *pTonBuf;
	DWORD	ulMaxSmp = min (m_ulSmpCnt, m_ulWrkSiz / sizeof (*pTonBuf));
	DWORD	uli;

	/////////////////////////////////////////////////////////////////////////
	// Lock tone sample work buffer
	/////////////////////////////////////////////////////////////////////////
	if (NULL == (pTonBuf = (GENSMP *) GloMemLck (m_hgWrkHdl))) return (this);

	/////////////////////////////////////////////////////////////////////////
	// If current buffer is empty, generate tone samples
	/////////////////////////////////////////////////////////////////////////
	if (!m_ulBytRem) for (uli = 0L; uli < ulMaxSmp; uli++) {
		DWORD	ulj;
		/////////////////////////////////////////////////////////////////////
		// Sum the sinusoids for all tones in the tone buffer
		/////////////////////////////////////////////////////////////////////
		float	flSigSum = (float) 0.0;
		for (ulj = 0; ulj < m_usSigCnt; ulj++) flSigSum += (float) 
			(m_pSigArr[ulj].flSigAmp * sin (m_pSigArr[ulj].flSigFrq * m_ulSigPos));
		pTonBuf[uli] = (GENSMP) flSigSum;
		/////////////////////////////////////////////////////////////////////
		// Update available byte count and signal phase position
		/////////////////////////////////////////////////////////////////////
		m_ulBytRem += sizeof (*pTonBuf);		
		m_ulSigPos++;
	}

	/////////////////////////////////////////////////////////////////////////
	// Write tones to output EBS 	
	/////////////////////////////////////////////////////////////////////////
	ulMaxSmp = Wr_PtoEBS (pTonBuf, &m_ulBytRem, ulMaxSmp, GENPCM000, PCMBIODEF, NULL);
	if (-1L != ulMaxSmp) m_ulSmpCnt -= ulMaxSmp;

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	GloMemUnL (m_hgWrkHdl);
	return (this);

}

CEffTon::~CEffTon()	
{
	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	GloAloRel (m_hgWrkHdl);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CEffMix::CEffMix (CAudFil *pFil000, WORD usLvl000, DWORD ulSmpOff, 
		DWORD *pulSmpCnt, CAudFil *pFil001, WORD usLvl001, WORD usAAFAlg, WORD usResAlg)
{
	/////////////////////////////////////////////////////////////////////////
	// Convert level percentages to normalized unity
	/////////////////////////////////////////////////////////////////////////
	m_flLvlArr[0] = (usLvl000 / (float) 100);
	m_flLvlArr[1] = (usLvl001 / (float) 100);

	/////////////////////////////////////////////////////////////////////////
	// Mix all tracks into pFil000
	/////////////////////////////////////////////////////////////////////////
	m_pTrk001 = new CEffInp (pFil001);
	m_pChn001 = new CEffChn (pFil000->GetChnCnt());
	m_pAAF001 = new CEffAAF (pFil000->GetSmpFrq() / 2L, pFil001->GetSmpFrq(), 
				(CEffAAF::AAFALG) usAAFAlg);
	m_pRes001 = new CEffRes (pFil001->GetSmpFrq(), pFil000->GetSmpFrq(), (CEffRes::RESALG) usResAlg);
	m_pAtD001 = new CEffAtD (pFil000->GetPCMTyp());

	/////////////////////////////////////////////////////////////////////////
	// Limit sample count to smallest file
	// Note: The file is truncated by AudFilEff if not limited in advance
	// Future: review entire mix strategy and AudFilEff usage
	/////////////////////////////////////////////////////////////////////////
	*pulSmpCnt = min (*pulSmpCnt, pFil000->GetSmpCnt() - min (ulSmpOff, pFil000->GetSmpCnt()));
	*pulSmpCnt = min (*pulSmpCnt, 
		m_pRes001->DstSizEst(m_pChn001->DstSizEst(pFil001->GetSmpCnt(), pFil001->GetChnCnt()),
		pFil001->GetSmpFrq()));

	/////////////////////////////////////////////////////////////////////////
	// Open the read-only tracks
	/////////////////////////////////////////////////////////////////////////
	if (!m_pTrk001->Open (CFile::modeRead, 0, -1L)) 
		CIFDspRes (MB_OKCANCEL, IDS_OPNFILERR);

	/////////////////////////////////////////////////////////////////////////
	return;

}
CAudEff	*	CEffMix::ExeEffPrc (CAudEff *pTrk000)
{
	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	m_pTrk001->ExeEffPrc ();
	m_pChn001->ExeEffPrc (m_pTrk001);
	m_pAAF001->ExeEffPrc (m_pChn001);
	m_pRes001->ExeEffPrc (m_pAAF001);
	m_pAtD001->ExeEffPrc (m_pRes001);

	/////////////////////////////////////////////////////////////////////////
	// Load array of source EBS blocks; [0] is the destination mix track
	/////////////////////////////////////////////////////////////////////////
	m_pEBSArr[0] = pTrk000->GetEBSBlk();
	m_pEBSArr[1] = m_pAtD001->GetEBSBlk();

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	EffMixMul (m_pEBSArr, &m_ebEBSBlk, MAXCHNCNT, m_flLvlArr);
	if (FIOEOSERR == m_ebEBSBlk.usEOSCod) CIFDspRes (MB_OKCANCEL, IDS_EBSEOSERR);

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	return (this);
}

CEffMix::~CEffMix ()
{
	/////////////////////////////////////////////////////////////////////////
	// Close mix source files
	/////////////////////////////////////////////////////////////////////////
	m_pTrk001->Close ();

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	delete m_pTrk001;
	delete m_pChn001;
	delete m_pAAF001;
	delete m_pRes001;
	delete m_pAtD001;

}

