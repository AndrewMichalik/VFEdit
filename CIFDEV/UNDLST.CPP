/////////////////////////////////////////////////////////////////////////////
// UndLst.cpp : Implementation of the CUndLst classes
// Copyright (c) 1987-1996 Andrew J. Michalik
/////////////////////////////////////////////////////////////////////////////
#include "gencif.h"						// Generic C I/F application defs

#include "tmpfil.h"						// Temp file support defs
#include "undlst.h"						// Undo file support defs

extern "C"
{
	#include "os_dev\winmsg.h"			// User message support
	#include <math.h>					// Math library defs
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
const char	SWPFILEXT[] = ".SWP";		// Swap file extension		  
const int	UNDEXTBAS =  10;			// Undo file extension modulo base
const int	UNDEXTLEN =   3;			// Undo file extension max length

/////////////////////////////////////////////////////////////////////////////
// CRepArr
/////////////////////////////////////////////////////////////////////////////
WORD		CRepArr::Read (LPOFSTRUCT_V pofDstFil, WORD usIdx, 
			FIOPOLPRC fpCBkPrc, DWORD ulCBkArg)
{
	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	DWORD ulOrgPos = (*this)[usIdx]->m_ulOrgPos;
	DWORD ulFinLen = (*this)[usIdx]->m_ulFinLen;
	DWORD ulTmpPos = (*this)[usIdx]->m_ulTmpPos;
	DWORD ulOrgLen = (*this)[usIdx]->m_ulOrgLen;

	/////////////////////////////////////////////////////////////////////////
	// Replace / Insert destination file; save cut portion
	/////////////////////////////////////////////////////////////////////////
	return (FIOOFSRep (pofDstFil, &ulOrgPos, &ulFinLen, NULL, 
		ulTmpPos, ulOrgLen, m_tfTmpFil.GetFilOFS(), fpCBkPrc, ulCBkArg));

}

WORD		CRepArr::Write (LPOFSTRUCT_V pofSrcFil, DWORD ulSrcPos, 
			DWORD ulOrgLen, DWORD ulFinLen, FIOPOLPRC fpCBkPrc, DWORD ulCBkArg)	
{
	DWORD	ulFilLen = FIOOFSLen (pofSrcFil);
	CRepRec	rrRepRec;

	/////////////////////////////////////////////////////////////////////////
	// Insure selection boundary conditions
	/////////////////////////////////////////////////////////////////////////
	ulSrcPos = min (ulSrcPos, ulFilLen);
	ulOrgLen = min (ulOrgLen, ulFilLen - ulSrcPos);

	/////////////////////////////////////////////////////////////////////////
	// Initialize event record
	/////////////////////////////////////////////////////////////////////////
	rrRepRec.m_ulOrgPos = ulSrcPos;
	rrRepRec.m_ulFinLen = ulFinLen;
	rrRepRec.m_ulTmpPos = 0L;
	rrRepRec.m_ulOrgLen = 0L;

	/////////////////////////////////////////////////////////////////////////
	// Anything to write?
	/////////////////////////////////////////////////////////////////////////
	if (ulOrgLen) {
		/////////////////////////////////////////////////////////////////////
		// Create undo data file if not already present
		/////////////////////////////////////////////////////////////////////
		if (!m_tfTmpFil.GetStatus() && m_tfTmpFil.IniFilOFS (m_csFilNam)) 
			return (-1);
	
		/////////////////////////////////////////////////////////////////////
		// Append data to end of current undo file
		/////////////////////////////////////////////////////////////////////
		rrRepRec.m_ulTmpPos = m_tfTmpFil.GetLength ();
		rrRepRec.m_ulOrgLen = ulOrgLen;
		if (FIOOFSApp (pofSrcFil, m_tfTmpFil.GetFilOFS(), ulSrcPos, ulOrgLen, 
		  fpCBkPrc, ulCBkArg)) return (-1);
	}
	
	/////////////////////////////////////////////////////////////////////////
	// Operation successful; set replacement record	(add if requested)
	/////////////////////////////////////////////////////////////////////////
	CRepRec	*	pRepRec = (*this)[Add(new CRepRec)];
	*pRepRec = rrRepRec;

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	return (0);

}

CRepArr	*	CRepArr::Rename (const char* pszFilNam)
{
	return (m_tfTmpFil.Rename (pszFilNam) ? NULL : this); 
}

/////////////////////////////////////////////////////////////////////////////
// CUndSta
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CUndSta, CObject)

/////////////////////////////////////////////////////////////////////////////
// CUndEvt
/////////////////////////////////////////////////////////////////////////////
CUndEvt::CUndEvt (WORD usSeqNum, CString csTmpPfx, CString csDesStr, CUndSta *pNewSta)
{
	const int	LTAMAXLEN = 101;		// itoa/ltoa max string length

	/////////////////////////////////////////////////////////////////////////
	// Insure sequence is modulo extension length
	/////////////////////////////////////////////////////////////////////////
	usSeqNum %= (WORD) pow (UNDEXTBAS, UNDEXTLEN);

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	m_usSeqNum = usSeqNum;
	m_csTmpPfx = csTmpPfx;
	m_csDesStr = csDesStr;
	m_pUndSta  = pNewSta;

	/////////////////////////////////////////////////////////////////////////
	// Pad extension with zeros
	/////////////////////////////////////////////////////////////////////////
	itoa (m_usSeqNum, m_csSeqExt.GetBuffer (LTAMAXLEN), UNDEXTBAS);
	m_csSeqExt.ReleaseBuffer();
	while (m_csSeqExt.GetLength() < UNDEXTLEN) m_csSeqExt = "0" + m_csSeqExt;
	m_csSeqExt = "." + m_csSeqExt;

	/////////////////////////////////////////////////////////////////////////
	m_paRepArr = new CRepArr (m_csTmpPfx + m_csSeqExt);
}

CUndEvt::~CUndEvt ()
{
	if (NULL != m_pUndSta) delete m_pUndSta;
	if (NULL != m_paRepArr) delete m_paRepArr;
}

WORD		CUndEvt::Do (LPOFSTRUCT_V pofSrcFil, DWORD ulSrcPos, DWORD ulOrgLen, 
			DWORD ulFinLen, FIOPOLPRC fpCBkPrc, DWORD ulCBkArg)	
{
	return (m_paRepArr->Write (pofSrcFil, ulSrcPos, ulOrgLen, ulFinLen, 
		fpCBkPrc, ulCBkArg));	
}

WORD		CUndEvt::Undo (LPOFSTRUCT_V pofDstFil, FIOPOLPRC fpCBkPrc, DWORD ulCBkArg)
{
	WORD		usIdx;
	CRepArr	*	pSwpArr;

	/////////////////////////////////////////////////////////////////////////
	// Rename current undo array, copy to swap and clear current
	/////////////////////////////////////////////////////////////////////////
	if (!(pSwpArr = m_paRepArr->Rename(m_csTmpPfx + SWPFILEXT))) return (-1);
	if (!(m_paRepArr = new CRepArr (m_csTmpPfx + m_csSeqExt))) return (-1);

	/////////////////////////////////////////////////////////////////////////
	// Walk backward through undo replacement records
	/////////////////////////////////////////////////////////////////////////
	for (usIdx = pSwpArr->GetSize(); usIdx > 0; usIdx--) {
		/////////////////////////////////////////////////////////////////////
		// Save previous state for next undo / redo
		/////////////////////////////////////////////////////////////////////
		if (m_paRepArr->Write (pofDstFil, (*pSwpArr)[usIdx-1]->m_ulOrgPos, 
			(*pSwpArr)[usIdx-1]->m_ulFinLen, (*pSwpArr)[usIdx-1]->m_ulOrgLen, 
			fpCBkPrc, ulCBkArg)) return (-1);

		/////////////////////////////////////////////////////////////////////
		// Replace / Insert destination file
		/////////////////////////////////////////////////////////////////////
		if (pSwpArr->Read (pofDstFil, usIdx-1, fpCBkPrc, ulCBkArg)) {
			// Attempt recovery
		}
	}

	/////////////////////////////////////////////////////////////////////////
	delete pSwpArr;

	/////////////////////////////////////////////////////////////////////////
	return (0);
}

WORD		CUndEvt::Redo (LPOFSTRUCT_V pofDstFil, FIOPOLPRC fpCBkPrc, DWORD ulCBkArg)
{
	WORD		usIdx;
	CRepArr	*	pSwpArr;

	/////////////////////////////////////////////////////////////////////////
	// Rename current undo array, copy to swap and clear current
	/////////////////////////////////////////////////////////////////////////
	if (!(pSwpArr = m_paRepArr->Rename(m_csTmpPfx + SWPFILEXT))) return (-1);
	if (!(m_paRepArr = new CRepArr (m_csTmpPfx + m_csSeqExt))) return (-1);

	/////////////////////////////////////////////////////////////////////////
	// Walk forward through undo replacement records
	/////////////////////////////////////////////////////////////////////////
	for (usIdx = 0; usIdx < (WORD) pSwpArr->GetSize(); usIdx++) {
		/////////////////////////////////////////////////////////////////////
		// Save previous state for next undo / redo
		/////////////////////////////////////////////////////////////////////
		if (m_paRepArr->Write (pofDstFil, (*pSwpArr)[usIdx]->m_ulOrgPos, 
			(*pSwpArr)[usIdx]->m_ulFinLen, (*pSwpArr)[usIdx]->m_ulOrgLen, 
			fpCBkPrc, ulCBkArg)) return (-1);

		/////////////////////////////////////////////////////////////////////
		// Replace / Insert destination file
		/////////////////////////////////////////////////////////////////////
		if (pSwpArr->Read (pofDstFil, usIdx, fpCBkPrc, ulCBkArg)) {
			// Attempt recovery
		}
	}

	/////////////////////////////////////////////////////////////////////////
	delete pSwpArr;

	/////////////////////////////////////////////////////////////////////////
	return (0);

}

/////////////////////////////////////////////////////////////////////////////
// CUndLst
/////////////////////////////////////////////////////////////////////////////
WORD		CUndLst::SetUndMax (WORD usUndMax)
{
	m_usUndMax = min (usUndMax, (WORD) pow (UNDEXTBAS, UNDEXTLEN));

	/////////////////////////////////////////////////////////////////////////
	// Set current position to NULL if undo has been inhibited
	/////////////////////////////////////////////////////////////////////////
	if (!m_usUndMax) m_vpUndPos = NULL;

	/////////////////////////////////////////////////////////////////////////
	// Remove oldest undo information
	// Note: Redo may still exceed max count, is adjusted on next create
	/////////////////////////////////////////////////////////////////////////
	while (((WORD) m_olUndLst.GetCount() > m_usUndMax) 
		&& (m_vpUndPos != m_olUndLst.GetHeadPosition())) RemoveHead();

	/////////////////////////////////////////////////////////////////////////
	return (m_usUndMax);

}

/////////////////////////////////////////////////////////////////////////////
// Note: The undo list must be maintained as a string of undos
//		 You cannot, for example, log an undo event and then decide to
//		 to skip a few. To skip, the entire log must be deleted.
//		 The invoking routines typically accept a NULL undo description
//		 to indicate continuation; to stop undo, destroy the chain and
//		 call with a NULL, thus not creating an undo event.
/////////////////////////////////////////////////////////////////////////////
POSITION	CUndLst::CreUndEvt (CString csDesStr, CUndSta *pNewSta)
{
	/////////////////////////////////////////////////////////////////////////
	// Delete tail of undo chain 
	/////////////////////////////////////////////////////////////////////////
	while (!IsEmpty() && (m_vpUndPos != m_olUndLst.GetTailPosition())) RemoveTail();

	/////////////////////////////////////////////////////////////////////////
	// Return NULL if undo has been inhibited
	/////////////////////////////////////////////////////////////////////////
	if (!m_usUndMax) return (NULL);

	/////////////////////////////////////////////////////////////////////////
	// Delete head to enforce maximum undo count; leave room for next
	/////////////////////////////////////////////////////////////////////////
	while ((WORD) m_olUndLst.GetCount() >= m_usUndMax) RemoveHead();

	/////////////////////////////////////////////////////////////////////////
	// Find previous files 3 digit extension and increment
	/////////////////////////////////////////////////////////////////////////
	WORD	usNxtExt = IsEmpty() ?  0 : GetTail()->GetSeqNum() + 1;

	/////////////////////////////////////////////////////////////////////////
	// Add new undo file
	/////////////////////////////////////////////////////////////////////////
	m_vpUndPos = m_olUndLst.AddTail (new CUndEvt (usNxtExt, m_csTmpPfx, csDesStr, pNewSta));
	return (m_vpUndPos);

}

BOOL		CUndLst::GetUndDes (CString *pcsDesStr, const CUndSta **ppUndSta)
{
	CUndEvt	*	pUndEvt = GetAt(m_vpUndPos);

	/////////////////////////////////////////////////////////////////////////
	if (ppUndSta) *ppUndSta = NULL;
	if (NULL == pUndEvt) return (FALSE);

	/////////////////////////////////////////////////////////////////////////
	if (pcsDesStr) *pcsDesStr = pUndEvt->GetDesStr();
	if (ppUndSta)  *ppUndSta  = pUndEvt->GetUndSta();
	return (TRUE);
}

BOOL		CUndLst::GetRedDes (CString *pcsDesStr, const CUndSta **ppUndSta)
{
	POSITION	vpTmpPos = m_vpUndPos;

	/////////////////////////////////////////////////////////////////////////
	GetNext (vpTmpPos);
	CUndEvt	*	pUndEvt = GetAt(vpTmpPos);

	/////////////////////////////////////////////////////////////////////////
	if (ppUndSta) *ppUndSta = NULL;
	if (NULL == pUndEvt) return (FALSE);

	/////////////////////////////////////////////////////////////////////////
	if (pcsDesStr) *pcsDesStr = pUndEvt->GetDesStr();
	if (ppUndSta)  *ppUndSta  = pUndEvt->GetUndSta();
	return (TRUE);
}

WORD		CUndLst::LogUndEvt (LPOFSTRUCT_V pofSrcFil, DWORD ulBytOff, 
			DWORD ulCutByt, DWORD ulPstByt, FIOPOLPRC fpCBkPrc, DWORD ulCBkArg)	
{
	/////////////////////////////////////////////////////////////////////////
	// Undo inhibited? Anything to log? 
	/////////////////////////////////////////////////////////////////////////
	if ((NULL == m_vpUndPos) || (!ulCutByt && !ulPstByt)) return (0);

	/////////////////////////////////////////////////////////////////////////
	CUndEvt *	pUndEvt	= GetAt (m_vpUndPos);
	if (!pUndEvt) return (-1); 

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	return (pUndEvt->Do (pofSrcFil, ulBytOff, ulCutByt, ulPstByt, fpCBkPrc, ulCBkArg));	

}

WORD		CUndLst::Un_UndEvt (LPOFSTRUCT_V pofDstFil, FIOPOLPRC fpCBkPrc, DWORD ulCBkArg)
{
	/////////////////////////////////////////////////////////////////////////
	// Undo inhibited?
	/////////////////////////////////////////////////////////////////////////
	if (NULL == m_vpUndPos) return (0);

	/////////////////////////////////////////////////////////////////////////
	// Get current event
	/////////////////////////////////////////////////////////////////////////
	CUndEvt	*	pUndEvt = GetAt(m_vpUndPos);
	if (NULL == pUndEvt) return (-1);

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	if (pUndEvt->Undo(pofDstFil, fpCBkPrc, ulCBkArg)) return (-1);

	/////////////////////////////////////////////////////////////////////////
	GetPrev(m_vpUndPos);
	return (0);
}

WORD		CUndLst::Re_UndEvt (LPOFSTRUCT_V pofDstFil, FIOPOLPRC fpCBkPrc, DWORD ulCBkArg)
{
	/////////////////////////////////////////////////////////////////////////
	// Move forward in chain; Undo inhibited?
	/////////////////////////////////////////////////////////////////////////
	GetNext(m_vpUndPos);
	if (NULL == m_vpUndPos) return (0);

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	CUndEvt	*	pUndEvt = GetAt(m_vpUndPos);
	if (NULL == pUndEvt) return (-1);

	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	if (pUndEvt->Redo(pofDstFil, fpCBkPrc, ulCBkArg)) return (-1);

	/////////////////////////////////////////////////////////////////////////
	return (0);
}

void		CUndLst::DelUndEvt ()
{
	POSITION	vpTmpPos = m_vpUndPos;
	GetPrev (m_vpUndPos);
	RemoveAt (vpTmpPos);
}

void		CUndLst::ClrUndLst ()
{
	/////////////////////////////////////////////////////////////////////////
	// Remove tail until NULL
	/////////////////////////////////////////////////////////////////////////
	while (!IsEmpty() && (m_vpUndPos = m_olUndLst.GetTailPosition())) RemoveTail();
}

/////////////////////////////////////////////////////////////////////////////
// CUndLst private functions
/////////////////////////////////////////////////////////////////////////////
CUndEvt	*	CUndLst::GetAt (POSITION position) const
{
	if (IsEmpty() || (NULL == position)) return (NULL);
	return ((CUndEvt *) m_olUndLst.GetAt(position));
}

CUndEvt	*	CUndLst::GetHead ()	const
{
	if (IsEmpty()) return (NULL);
	return ((CUndEvt *) m_olUndLst.GetHead());
}

CUndEvt	*	CUndLst::GetTail ()	const
{
	if (IsEmpty()) return (NULL);
	return ((CUndEvt *) m_olUndLst.GetTail());
}

CUndEvt	*	CUndLst::GetNext (POSITION& position) const
{
	if (IsEmpty()) {
		position = NULL;
		return (NULL);
	}

	/////////////////////////////////////////////////////////////////////////
	// NULL points to the position BEFORE the first postion
	/////////////////////////////////////////////////////////////////////////
	if (NULL == position) {
		position = m_olUndLst.GetHeadPosition ();
		return (NULL);
	}
	return ((CUndEvt *) m_olUndLst.GetNext(position));
}

CUndEvt	*	CUndLst::GetPrev (POSITION& position) const
{
	if (IsEmpty() || (NULL == position)) {
		position = NULL;
		return (NULL);
	}
	return ((CUndEvt *) m_olUndLst.GetPrev(position));
}

BOOL		CUndLst::IsEmpty () const
{
	return (m_olUndLst.IsEmpty());
}

void		CUndLst::RemoveAt (POSITION position)
{
	if (IsEmpty() || (NULL == GetAt(position))) return;
	delete (GetAt(position));
	m_olUndLst.RemoveAt(position);
}

void		CUndLst::RemoveHead()
{
	if (IsEmpty()) return;
	delete (m_olUndLst.RemoveHead());
}

void		CUndLst::RemoveTail()
{
	if (IsEmpty()) return;
	delete (m_olUndLst.RemoveTail());
}


